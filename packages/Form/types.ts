import {ReactNode} from 'react';
import {StyleProp, TextStyle, ViewStyle} from 'react-native';

export declare type ValidateMessages = {
  required?: string;
  whitespace?: string;
  len?: string;
  min?: string;
  max?: string;
  pattern?: string;
  enum?: string;
};

export enum TriggerAction {
  onChange = 'onChange',
  onBlur = 'onBlur',
  all = 'all',
}

export declare type Rule = {
  required?: boolean; //Display required style. It will be generated by the validation rule
  enum?: any[]; //Match enum value. You need to set type to enum to enable this
  len?: number; //Length of string
  max?: number; // max of number
  min?: number; // min of number
  message?: string; //Error message. Will auto generate by template if not provided
  pattern?: RegExp; //Regex pattern
  transform?: (value: any) => any; //Transform value to the rule before validation
  validateTrigger?: TriggerAction | 'onChange' | 'onBlur';
  validator?: (
    rule: Rule & {name: string},
    value: any,
    callback: (errorMessage?: string) => void,
  ) => Promise<void | Error>; //Customize validation rule. Accept Promise as return. See example
  whitespace?: boolean; //Failed if only has whitespace
};

export declare type FormItem<T = any, K extends keyof T = keyof T> = {
  name: K;
  label?: string; //Label text
  initialValue?: T[K]; //Label text
  rules?: Rule[];
  required?: boolean; //Display required style. It will be generated by the validation rule
  validateTrigger?: TriggerAction.onBlur | TriggerAction.onChange; //When to validate the value of children node
  preserve?: boolean; //Keep field value even when field removed
  style?: StyleProp<ViewStyle>;
  getValueProps?: (v: T[K]) => any;
  children:
    | ((handle: {
        onChangeValue: (value: T[K]) => void;
        onBlur: () => void;
        value?: T[K];
        error?: string;
      }) => ReactNode)
    | React.ReactNode;
};

export const defaultValidateMessages = {
  required: '${name} is required',
  whitespace: '${name} cannot be empty',
  len: '${name} must be exactly ${len} characters',
  min: '${name} must be less than ${min}',
  max: '${name} cannot be greater than ${max}',
  pattern: '${name} does not match pattern ${pattern}',
  enum: '${name} must be one of ${enum}',
};

export declare type FilterGetValues = (touched: boolean) => true;

export declare type ValueValidateField<T = any> = {
  values: T;
  errors?: {[key: string]: string};
};

export type NamePath<T> = Extract<keyof T, string> | (string & {});

export declare type FormInstance<T = Record<string, any>> = {
  getFieldError: (
    name: NamePath<T>,
  ) => string | undefined | Record<string, string>;
  getFieldsError: (
    names?: NamePath<T>[],
  ) => Promise<{[key: string]: string | undefined}>; //Get the error messages by the fields name. Return as an array
  getFieldsValue: (
    names?: NamePath<T>[],
    filter?: FilterGetValues,
  ) => Promise<any>; //Get values by a set of field names. Return according to the corresponding structure. Default return mounted field value, but you can use getFieldsValue() to get all values
  getFieldValue: (name: NamePath<T>) => any; //Get the value by the field name
  isFieldsTouched: (names?: string[]) => boolean; //Check if fields have been operated. Check if all fields is touched
  isFieldTouched: (name: NamePath<T>) => boolean; //Check if a field has been operated
  resetFields: (fields?: NamePath<T>[]) => Promise<void>; //Reset fields to initialValues
  setFieldValue: (name: keyof T, value: any) => void; //Set fields value(Will directly pass to form store. If you do not want to modify passed object, please clone first)
  setFieldsValue: (values: {[key in NamePath<T>]?: any}) => Promise<void>; //Set fields value(Will directly pass to form store. If you do not want to modify passed object, please clone first).
  validateFields: (names?: NamePath<T>[]) => Promise<ValueValidateField<T>>; //Validate fields
  setFieldError: (name: NamePath<T>, error?: string | false) => void;
  initialValues?: Partial<T>;
};

export type TForm<T = any> = {
  form: FormInstance<T>;
  colon?: boolean; //Configure the default value of colon for Form.Item. Indicates whether the colon after the label is displayed (only effective when prop layout is horizontal)
  initialValues?: Partial<T>; //default values
  labelAlign?: 'left' | 'right'; //The text align of label of all items
  name?: string; //Form name. Will be the prefix of Field id
  preserve?: boolean; //Keep field value even when field removed
  requiredMark?: boolean | string; //Required mark style. Can use required mark or optional mark. You can not config to single Form.Item since this is a Form level config
  requiredMarkStyle?: StyleProp<TextStyle>;
  requiredMarkPosition?: 'before' | 'after';
  validateMessages?: ValidateMessages; //Validation prompt template
  validateTrigger?: TriggerAction | 'onChange' | 'onBlur'; //Config field validate trigger
  onValuesChange?: (values: {[key: string]: any}) => void; //Trigger when value updated
  errorStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  style?: StyleProp<ViewStyle>;
};
export type TItemValue = {value: any; error?: string};

export type TField = {
  [key: string]: Omit<FormItem, 'name' | 'children'> & {
    triggerState?: React.Dispatch<React.SetStateAction<TItemValue>>;
  };
};
